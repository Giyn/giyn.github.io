<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="Giyn"><meta name="copyright" content="Giyn"><meta name="generator" content="Hexo 5.1.1"><meta name="theme" content="hexo-theme-yun"><title>Python 内存分配与垃圾回收 | Giyn's Blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.19/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
  renderMathInElement(document.body, {
    delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "$", right: "$", display: false},
      {left: "\\(", right: "\\)", display: false},
      {left: "\\[", right: "\\]", display: true}
    ]
  });
});</script><link rel="shortcut icon" type="image/svg+xml" href="/Giyn.ico"><link rel="mask-icon" href="/Giyn.ico" color="#6200ee"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><link rel="alternate" href="/atom.xml" title="Giyn's Blog" type="application/atom+xml"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"许继元的博客","version":"1.0.0","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"/data/sentences.json"},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><meta name="description" content="计算机存储器的分类根据计算机存储器的作用，存储器可以分为主存储器、辅助存储器和缓冲存储器。 内存的定义主存储器也称主存、内存或可执行存储器，是与 CPU 直接进行信息交换的存储器，其读写速度相对较快，容量相对较小，通常用来保存进程运行时的程序和相应数据以供 CPU 使用；而辅助存储器不能与 CPU 直接进行信息交换，其读写速度相对较慢，容量相对较大。缓冲存储器常用于两个速度不同的部件之间，比如 C">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 内存分配与垃圾回收">
<meta property="og:url" content="http://giyn.work/posts/a13f9ad3/index.html">
<meta property="og:site_name" content="Giyn&#39;s Blog">
<meta property="og:description" content="计算机存储器的分类根据计算机存储器的作用，存储器可以分为主存储器、辅助存储器和缓冲存储器。 内存的定义主存储器也称主存、内存或可执行存储器，是与 CPU 直接进行信息交换的存储器，其读写速度相对较快，容量相对较小，通常用来保存进程运行时的程序和相应数据以供 CPU 使用；而辅助存储器不能与 CPU 直接进行信息交换，其读写速度相对较慢，容量相对较大。缓冲存储器常用于两个速度不同的部件之间，比如 C">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/01/26/su5O2dUHwqPrMeT.png">
<meta property="og:image" content="https://i.loli.net/2021/01/26/aJGrZ7TNMqjbYHR.png">
<meta property="og:image" content="https://i.loli.net/2021/01/26/m9TsbrWug3DQx2p.png">
<meta property="og:image" content="https://i.loli.net/2021/01/26/NPrtUsiZv7o8Mkm.png">
<meta property="og:image" content="https://i.loli.net/2021/01/26/HLXQJWMFpOy5rDq.png">
<meta property="og:image" content="https://i.loli.net/2021/01/26/VEsnhOj2TqoNFxD.png">
<meta property="og:image" content="https://i.loli.net/2021/01/26/Iufm4gnbtBTC1EK.png">
<meta property="article:published_time" content="2021-01-25T15:36:06.000Z">
<meta property="article:modified_time" content="2021-01-26T07:02:41.463Z">
<meta property="article:author" content="Giyn">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Computer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/01/26/su5O2dUHwqPrMeT.png"><script src="/js/ui/mode.js"></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="Giyn"><img width="96" loading="lazy" src="/images/avatar.png" alt="Giyn"></a><div class="site-author-name"><a href="/about/">Giyn</a></div><a class="site-name" href="/about/site.html">Giyn's Blog</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">60</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">41</span></a></div><a class="site-state-item hty-icon-button" href="/about/"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-open-arm-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Giyn" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:giyn.jy@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=490601115&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/443380473" title="bilibili" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/jiyuan_xu" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">计算机存储器的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">内存的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">操作系统的内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">进程内的内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">4.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">4.0.1.</span> <span class="toc-text">内存池机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">4.0.2.</span> <span class="toc-text">分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">4.0.3.</span> <span class="toc-text">缓冲池机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">5.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%EF%BC%9A%E5%90%8D%E5%AD%97%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">Python 中的引用关系：名字、对象、引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-Counting%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">引用计数（Reference Counting）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">引用计数的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.2.</span> <span class="toc-text">引用计数的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88Mark-and-Sweep%EF%BC%89%E5%92%8C%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%88Generational%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">标记清除（Mark and Sweep）和分代回收（Generational）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">5.3.1.</span> <span class="toc-text">分代回收</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://giyn.work/posts/a13f9ad3/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Giyn"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Giyn's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Python 内存分配与垃圾回收<a class="post-edit-link" href="https://github.com/Giyn/giyn.github.io/tree/hexo/source/_posts/Python 内存分配与垃圾回收.md" target="_blank" title="Edit this post" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">Posted on</span> <time title="Created: 2021-01-25 23:36:06" itemprop="dateCreated datePublished" datetime="2021-01-25T23:36:06+08:00">2021-01-25</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <span class="post-meta-icon-text">Edited on</span> <time title="Modified: 2021-01-26 15:02:41" itemprop="dateModified" datetime="2021-01-26T15:02:41+08:00">2021-01-26</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Words count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Words count in article">3.4k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">11m</span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/Python/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Python</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/Python/" style="--text-color:#3776ab"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Python</span></a><a class="tag" href="/tags/Computer/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Computer</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#6200ee;"><h2 id="计算机存储器的分类"><a href="#计算机存储器的分类" class="headerlink" title="计算机存储器的分类"></a>计算机存储器的分类</h2><p>根据计算机存储器的作用，存储器可以分为主存储器、辅助存储器和缓冲存储器。</p>
<h2 id="内存的定义"><a href="#内存的定义" class="headerlink" title="内存的定义"></a>内存的定义</h2><p>主存储器也称主存、内存或可执行存储器，是与 CPU 直接进行信息交换的存储器，其读写速度相对较快，容量相对较小，通常用来保存进程运行时的程序和相应数据以供 CPU 使用；而辅助存储器不能与 CPU 直接进行信息交换，其读写速度相对较慢，容量相对较大。缓冲存储器常用于两个速度不同的部件之间，比如 CPU 和主存之间设置的高速缓冲存储 Cache。</p>
<p><img src="https://i.loli.net/2021/01/26/su5O2dUHwqPrMeT.png" alt="5d2c7de9b0c548a5bc9e1ec8dc16a17.png" loading="lazy"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h3><p>由于内存的容量有限，很难承载系统以及用户进程所需的全部信息，所以操作系统需要对内存空间进行存储管理。在操作系统层面上内存管理的实现相当复杂，其大致功能包括内存空间的划分与动态分配、回收、扩充以及存储保护、地址转换等。</p>
<h3 id="进程内的内存管理"><a href="#进程内的内存管理" class="headerlink" title="进程内的内存管理"></a>进程内的内存管理</h3><p>操作系统对各个进程的内存进行管理，同时我们也需要管理我们编写的程序所对应进程内的内存，从可用内存中申请内存并且具有足够内存来进行相关操作，以及在适当的时间释放内存，这些都是程序和系统能够正常运行的前提。</p>
<p>在 C / C++ 中需要手动的进行内存管理，如 C 语言中通过 <code>malloc</code> 和 <code>free</code> 函数来申请给定字节数的内存以及释放对应的内存。但在 Python 中无须手动进行内存的申请和释放，Python 在内部已经完成了大量涉及到内存管理的操作，包括内存分配及垃圾回收。</p>
<p><img src="https://i.loli.net/2021/01/26/aJGrZ7TNMqjbYHR.png" alt="b4e0af7ddafedfddfc15deb917f2642.png" loading="lazy"></p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h4 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h4><p>在 Python 中，有列表、字典等常用的数据结构。如在列表中不仅可以保存其他不同类型的对象，而且可以非常方便的使用 <code>append</code>、<code>extend</code> 等方法进行动态扩充。但常用数据结构的一系列操作会造成内存的频繁分配和释放，而且像 <code>int</code>、<code>list</code> 等 Python 对象的内存分配和释放涉及到的数据量通常相对较小，因此 Python 引入了内存池机制，实现了小块内存的管理器（PyMalloc ）用于提高处理小块内存的效率，由此来避免底层中频繁的 <code>malloc</code> 和 <code>free</code> 操作对效率带来的影响。</p>
<h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>在内存分配中，Python 以 512 bytes 为界限对大内存和小内存进行划分，不超过 512 bytes 的内存申请，会通过 PyMalloc 管理器进行处理，超过 512 bytes 的内存申请，则会通过 C 中的 <code>malloc</code> 来进行处理。在管理器的内部，主要包括 <code>block</code>、<code>pool</code>、<code>arena</code> 层级， 其中 <code>block</code>是 Python 内存管理中的最小单元，一个 <code>pool</code> 中包含多个 <code>block</code>，多个 <code>pool</code> 构成一个 <code>arena</code>。 同时，由于内存池机制，Python 并不会将释放的内存立即归还操作系统。</p>
<h4 id="缓冲池机制"><a href="#缓冲池机制" class="headerlink" title="缓冲池机制"></a>缓冲池机制</h4><p>在内存池机制的基础上，Python 为了提高常用对象的创建和释放效率，又进一步对整数、字符串等对象建立了对象缓冲池。如对于 [-5, 256] 内的小整数，Python 已经在内部创建好了对应的小整数对象的缓冲池。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是一种自动回收内存的技术，会将不再被使用的内存空间进行释放。在 CPython 中，垃圾回收主要是通过<strong>引用计数、标记清除及分代回收</strong>来完成的。使用引用计数来检测并清除不可访问的对象，并结合标记清除及分代回收来收集、定期检测及清除具有引用循环的对象。</p>
<p>在 CPython 之外的一些其他实现中，它们的垃圾回收机制和 CPython 通常会有所不同，比如 PyPy 或 Jython。一些依赖 CPython 中引用计数的代码在这些实现下可能会出现问题，比如在 CPython 中使用 <code>open()</code> 打开相关文件后，可以不用显式的关闭它：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> line <span class="token keyword">in</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	do_something_with_line<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>但在其他实现中如果不显式地关闭打开的文件，则有可能会出现文件描述符耗尽的情况。此处可以使用 <code>with</code> 语句声明一个上下文管理器的方法，这样代码就不依赖于任何实现，在可移植性和通用性上更佳。</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
	    do_something_with_line<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>虽然垃圾回收机制隐藏在 Python 内部，但它非常重要，相比于 C 程序员手动进行内存的申请和释放（可能会造成内存泄露等相关问题），Python 的垃圾回收机制在背后完成了大量工作：</p>
<h3 id="Python-中的引用关系：名字、对象、引用"><a href="#Python-中的引用关系：名字、对象、引用" class="headerlink" title="Python 中的引用关系：名字、对象、引用"></a>Python 中的引用关系：名字、对象、引用</h3><p>此处先理解 Python 中名字和对象之间的引用关系：</p>
<p>先看看在 C 语言中有关变量声明和赋值的一段代码：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>

<p>第一行表示声明及初始化变量，即为变量创建和标记存储空间，并指定了初始值；第二行表示为变量重新赋值。整个过程可以使用下图来表明，可以看到的是，在给变量重新赋值后，相同地址上的值被修改为 2。变量名 <code>a</code> 可称为标识符，此处可以把变量理解为一块内存，把变量名理解为<strong>内存别名</strong>，声明过程把标识符和内存中某个特定的位置关联了起来，同时也确定了该位置存储的数据类型。</p>
<p><img src="https://i.loli.net/2021/01/26/m9TsbrWug3DQx2p.png" alt="224294513e01a00dd9052febd8aabd4.png" loading="lazy"></p>
<p>在 Python 中有如下代码：</p>
<pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>
a <span class="token operator">=</span> <span class="token number">2</span></code></pre>

<p>在 Python 中，此过程和 C 语言中有很大区别。在 Python 中，可以把变量名称为名字（name），把对象理解为分配的一块内存，名字和对象之间的关联关系称为引用（此种引用关系和 C 语言中的指针类似）。因此重新赋值修改的是引用关系，名字 <code>a</code> 重新关联到另外一个对象 <code>2</code> 上，而不是修改原来的对象 <code>1</code>。</p>
<p><img src="https://i.loli.net/2021/01/26/NPrtUsiZv7o8Mkm.png" alt="76e92c96af3bd3ef14e9f986b4e75a1.png" loading="lazy"></p>
<p>Python 中的名字和 C 语言中的标识符都可以理解为变量名，但在两种语言中对变量名的处理方式是不同的。C 语言中的标识符相当于内存的别称，<strong>在执行过程中会被替代</strong>；而在 Python 中，名字会参与到运行过程中，并且<strong>名字和对象的映射关系会存放在命名空间中</strong>。</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 以字典形式返回全局命名空间</span>
<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre>

<h3 id="引用计数（Reference-Counting）"><a href="#引用计数（Reference-Counting）" class="headerlink" title="引用计数（Reference Counting）"></a>引用计数（Reference Counting）</h3><p>引用计数是一种内存管理技术，通过对对象的引用计数进行跟踪从而实现自动的内存管理，Python 的垃圾回收便是以引用计数为主的。对象的引用计数随着程序的运行进行变动，当对象的引用计数变为零时，对应的内存便会被释放。可以通过 <code>sys.getrefcount</code> 来查看某个对象的引用计数。</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">"hello world"</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment"># 输出结果会比我们预期多1，因为a在sys.getrefcount()中作为参数也被引用了一次</span>
<span class="token number">2</span></code></pre>

<h4 id="引用计数的实现"><a href="#引用计数的实现" class="headerlink" title="引用计数的实现"></a>引用计数的实现</h4><p>在 Python 对象的实现中，每个对象中都持有一个统计引用次数的计数器，当该计数器变为 0 时，对应对象的内存空间就会被回收。源码 <a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Include/object.h"><code>object.h</code></a> 中的 <code>PyObject</code> 是 Python 对象系统中最基础的部分，它的一个成员便是引用计数变量 <code>ob_refcnt</code>。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_object</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* 省略部分代码 */</span>
    Py_ssize_t ob_refcnt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">_typeobject</span> <span class="token operator">*</span>ob_type<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> PyObject<span class="token punctuation">;</span></code></pre>

<h4 id="引用计数的问题"><a href="#引用计数的问题" class="headerlink" title="引用计数的问题"></a>引用计数的问题</h4><p>引用计数在原理和实现上相对简单，并且延迟低、实时性强，对于内存的回收分布在程序的运行时，不会造成瞬时的卡顿。但引用计数占用了较多的空间（每个对象都持有一个引用计数变量 <code>ob_refcnt</code>），频繁地引用计数增减。</p>
<p>此外，引用计数还存在两个问题：</p>
<ul>
<li>引用计数无法处理循环引用；</li>
<li>引用计数是非线程安全的。</li>
</ul>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>循环引用的例子：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">point</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>point <span class="token operator">=</span> value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         
<span class="token operator">>></span><span class="token operator">></span> container_one <span class="token operator">=</span> Container<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> container_two <span class="token operator">=</span> Container<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> container_one<span class="token punctuation">.</span>point<span class="token punctuation">(</span>container_two<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> container_two<span class="token punctuation">.</span>point<span class="token punctuation">(</span>container_one<span class="token punctuation">)</span></code></pre>

<p>此处使用 <code>objgraph</code> 来可视化上述创建的对象（<code>objgraph</code> 是一个用于定位内存泄露的工具）：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在终端中进入虚拟环境</span>
workon python-core-tech
<span class="token comment"># 安装第三方库</span>
pip <span class="token function">install</span> objgraph
<span class="token comment"># objgraph库会生成可视化图片</span>
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> graphvi
<span class="token operator">>></span><span class="token operator">></span> <span class="token function">import</span> objgraph
<span class="token operator">>></span><span class="token operator">></span> objgraph.show_backrefs<span class="token punctuation">(</span>container_one, <span class="token assign-left variable">max_depth</span><span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">filename</span><span class="token operator">=</span><span class="token string">"container.png"</span><span class="token punctuation">)</span>
Graph written to /tmp/objgraph-o748tdfx.dot <span class="token punctuation">(</span><span class="token number">31</span> nodes<span class="token punctuation">)</span>
Image generated as container.png</code></pre>

<p>此处截取生成图片的一部分，定位到代码中的关键字，如 <code>container_one</code>、<code>container_two</code>、<code>point</code>。</p>
<p><img src="https://i.loli.net/2021/01/26/HLXQJWMFpOy5rDq.png" alt="856c4af00a78648a4a85005594f63e8.png" loading="lazy"></p>
<p>把上图的关系简化一下得到下图，指向对象的箭头数量可以理解为对象的引用计数， <code>container_one</code>、<code>container_two</code> 的引用计数都为 2。如下图所示，<code>container_one</code>、<code>container_two</code> 之间便构成了循环引用。循环引用是一个对象直接或者间接引用自身，从而在引用关系上构成环状结构。另外，在 Python 中将能够持有其他对象引用的对象称为容器（ container ），只有容器对象才能造成循环引用。</p>
<p><img src="https://i.loli.net/2021/01/26/VEsnhOj2TqoNFxD.png" alt="cd25b2c7c2d44048dac687e42fbd027.png" loading="lazy"></p>
<p>清除掉命名空间内<code>container_one</code>、<code>container_two</code>的引用：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">del</span> container_one
<span class="token keyword">del</span> container_two</code></pre>

<p>如下图，在上面的引用被解除后，预期中这两个对象的内存应该被回收，但这两个对象由于循环引用其引用计数仍然为 1，根据引用计数并不能对其内存进行释放。当这种循环引用的对象达到一定数量后，会造成比较严重的<strong>内存泄露</strong>问题。</p>
<p><img src="https://i.loli.net/2021/01/26/Iufm4gnbtBTC1EK.png" alt="8675dfe84c125b77ddc45c988dfbdd8.png" loading="lazy"></p>
<p>另一种常见的循环引用是一个序列对象包含自身的引用，如下例，Python 会自动将循环引用部分打印为 <code>[...]</code>，从而避免严重的无限循环。</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> lis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> lis<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lis
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre>

<h3 id="标记清除（Mark-and-Sweep）和分代回收（Generational）"><a href="#标记清除（Mark-and-Sweep）和分代回收（Generational）" class="headerlink" title="标记清除（Mark and Sweep）和分代回收（Generational）"></a>标记清除（Mark and Sweep）和分代回收（Generational）</h3><p>为了<strong>解决引用计数在垃圾回收中无法处理循环引用</strong>的问题，Python 引入了标记清除和分代回收来<strong>检测和打破循环引用</strong> 。标记清除是追踪回收中的一种基础算法，其涉及到两个主要过程，即标记过程和清除过程，在标记过程中将所有可达对象进行标记，在清除过程中将所有未标记的对象进行清除。分代回收则是基于标记清除基础上的一种空间换时间的实现策略。</p>
<h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>分代回收将 Python 对象划分成 3 代，包括 0、1、2 代。对于新创建的对象，会被放入 0 代。若一个对象在经过一次垃圾回收后没有被清除，则它会被放入下一代中。对于每一代对象来说，都具有触发垃圾回收的相关阈值（收集频率）。关于这个过程的细节，官方文档中给出了比较明确的描述：</p>
<blockquote>
<p>垃圾回收器把所有对象分类为 3 代，取决于对象幸存于多少次垃圾回收。新创建的对象会被放第 <code>0</code> 代。如果一个对象幸存于一次垃圾回收，则该对象会被放入下一代。第 <code>2</code> 代是最老的一代，因此这一代的对象幸存于垃圾回收后，仍会留在第 <code>2</code> 代。</p>
<p>为了判定何时需要进行垃圾回收，垃圾回收器会跟踪上一次回收后，分配和释放的对象的数目。当分配对象的数量减去释放对象的数量大于阈值 <em>threshold0</em> 时，回收器开始进行垃圾回收。起初只有第 <code>0</code> 代会被检查。当上一次第 <code>1</code> 代被检查后，第 <code>0</code> 代被检查的次数多于阈值 <em>threshold1</em> 时，第 <code>1</code> 代也会被检查。相似的， <em>threshold2</em> 设置了触发第 <code>2</code> 代被垃圾回收的第 <code>1</code> 代被垃圾回收的次数。</p>
</blockquote>
<p>分代回收的主要目的是降低回收中需要处理的对象数量，提高垃圾回收效率。可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc"><code>gc</code></a> 模块来执行或优化垃圾回收的相关过程，并获取更多的调试信息，比如通过 <code>gc.get_threshold()</code> 来获取当前的回收阈值；通过 <code>gc.disable()</code> 关闭垃圾回收，这通常在程序中确定不存在循环引用时使用。</p>
<p>CPython 在退出时不一定会释放所有内存，当 Python 解释器退出时，会进行内存清理，试图释放每个对象的内存，但不一定会释放所有内存，如全局命名空间中引用的某些对象、循环引用下 C 扩展库中分配的某些内存都有可能不被释放。</p>
<hr>
<p>Reference：<a target="_blank" rel="noopener" href="http://www.imooc.com/read/79/article/2140">Python 在垃圾回收中如何解决循环引用问题？</a></p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/Ali-Pay.jpg"><img loading="lazy" src="/images/Ali-Pay.jpg" alt="Ali-Pay" title="Ali-Pay"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/WeChatPay.jpg"><img loading="lazy" src="/images/WeChatPay.jpg" alt="WeChat Pay" title="WeChat Pay"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Giyn</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://giyn.work/posts/a13f9ad3/" title="Python 内存分配与垃圾回收">http://giyn.work/posts/a13f9ad3/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless stating additionally.</li></ul><script>document.addEventListener('copy', function (event) {
  const clipboardData = event.clipboardData || window.clipboardData;
  if (!clipboardData) { return; }
  const text = window.getSelection().toString();
  if (text) {
    event.preventDefault();
    clipboardData.setData('text/plain', text + '\n\nPost author: Giyn\nPost link: http://giyn.work/posts/a13f9ad3/\nCopyright Notice: All articles in this blog are licensed under CC BY-NC-SA 4.0 unless stating additionally.');
  }
});</script></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/9b4f9c18/" rel="prev" title="使用 Pyppeteer 的 evaluateOnNewDocument 方法时出现 Object.defineProperty(...) is not a function 的解决方案"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">使用 Pyppeteer 的 evaluateOnNewDocument 方法时出现 Object.defineProperty(...) is not a function 的解决方案</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/21c8089f/" rel="next" title="SMOTE 算法"><span class="post-nav-text">SMOTE 算法</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Giyn</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.1.1</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.0.0</span></div><div class="live_time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-09-03T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div><script>const date = new Date();
const today = (date.getMonth() + 1) + "-" + date.getDate()
const mourn_days = ["4-4"]
if (mourn_days.includes(today)) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>